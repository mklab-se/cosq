//! Queries management commands â€” list, create, edit, delete, show, generate
//!
//! Manages stored .cosq query files in `~/.cosq/queries/` (user-level)
//! and `.cosq/queries/` (project-level).

use anyhow::{Context, Result, bail};
use colored::Colorize;
use cosq_core::config::Config;
use cosq_core::stored_query::{
    StoredQuery, StoredQueryMetadata, find_stored_query, list_stored_queries, query_file_path,
    user_queries_dir,
};

use crate::cli::QueriesCommands;

pub async fn run(cmd: QueriesCommands, quiet: bool) -> Result<()> {
    match cmd {
        QueriesCommands::List => list(),
        QueriesCommands::Create { name, project } => create(&name, project),
        QueriesCommands::Edit { name } => edit(&name),
        QueriesCommands::Delete { name, yes } => delete(&name, yes),
        QueriesCommands::Show { name } => show(&name),
        QueriesCommands::Generate {
            description,
            project,
        } => generate(&description, project, quiet).await,
    }
}

fn list() -> Result<()> {
    let queries = list_stored_queries().unwrap_or_default();

    if queries.is_empty() {
        println!("No stored queries found.");
        println!(
            "\n  Create one with: {}",
            "cosq queries create <name>".cyan()
        );
        return Ok(());
    }

    println!(
        "{} ({}):\n",
        "Stored queries".bold(),
        "~/.cosq/queries/".dimmed()
    );

    let max_name_len = queries.iter().map(|q| q.name.len()).max().unwrap_or(0);

    for query in &queries {
        let ai_badge = if query.metadata.generated_by.is_some() {
            " (AI)".dimmed().to_string()
        } else {
            String::new()
        };
        println!(
            "  {:<width$}  {}{}",
            query.name.green().bold(),
            query.metadata.description.dimmed(),
            ai_badge,
            width = max_name_len,
        );
    }

    println!("\n{} queries found.", queries.len());
    Ok(())
}

fn create(name: &str, project: bool) -> Result<()> {
    let path = query_file_path(name, project)?;

    if path.exists() {
        bail!(
            "Query '{}' already exists at {}. Use `cosq queries edit {}` to modify it.",
            name,
            path.display(),
            name
        );
    }

    // Create parent directory
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent)?;
    }

    // Write a template .cosq file
    let template = StoredQueryMetadata {
        description: "TODO: describe what this query does".to_string(),
        database: None,
        container: None,
        params: Vec::new(),
        template: None,
        template_file: None,
        generated_by: None,
        generated_from: None,
    };
    let yaml = serde_yaml::to_string(&template)?;
    let contents =
        format!("---\n{yaml}---\n-- Write your Cosmos DB SQL query below\nSELECT * FROM c\n");
    std::fs::write(&path, &contents)?;

    println!("{} Created {}", "OK".green().bold(), path.display());

    // Open in editor
    open_in_editor(&path)?;

    Ok(())
}

fn edit(name: &str) -> Result<()> {
    // Find the query file
    let path = find_query_path(name)?;

    // Verify it parses before opening
    let _ = StoredQuery::load(&path).map_err(|e| anyhow::anyhow!("Query file has errors: {e}"))?;

    open_in_editor(&path)?;
    Ok(())
}

fn delete(name: &str, yes: bool) -> Result<()> {
    let path = find_query_path(name)?;

    if !yes {
        let confirm = dialoguer::Confirm::with_theme(&dialoguer::theme::ColorfulTheme::default())
            .with_prompt(format!("Delete query '{name}' at {}?", path.display()))
            .default(false)
            .interact()
            .context("confirmation cancelled")?;

        if !confirm {
            println!("Cancelled.");
            return Ok(());
        }
    }

    std::fs::remove_file(&path)?;
    println!("{} Deleted query '{name}'.", "OK".green().bold());
    Ok(())
}

fn show(name: &str) -> Result<()> {
    let query =
        find_stored_query(name).map_err(|e| anyhow::anyhow!("Query '{name}' not found: {e}"))?;

    println!("{}", query.name.green().bold());
    println!("  {} {}", "Description:".bold(), query.metadata.description);

    if let Some(ref db) = query.metadata.database {
        println!("  {}  {}", "Database:".bold(), db);
    }
    if let Some(ref ctr) = query.metadata.container {
        println!("  {} {}", "Container:".bold(), ctr);
    }

    let has_template = query.metadata.template.is_some() || query.metadata.template_file.is_some();
    println!(
        "  {}  {}",
        "Template:".bold(),
        if has_template { "yes" } else { "(none)" }
    );

    if let Some(ref generated) = query.metadata.generated_by {
        println!("  {} {}", "Generated by:".bold(), generated);
    }
    if let Some(ref prompt) = query.metadata.generated_from {
        println!("  {}  \"{}\"", "Prompt:".bold(), prompt);
    }

    if !query.metadata.params.is_empty() {
        println!("\n  {}:", "Parameters".bold());
        for param in &query.metadata.params {
            let type_str = param.param_type.to_string();
            let desc = param.description.as_deref().unwrap_or("");
            let default_str = param
                .default
                .as_ref()
                .map(|d| format!(" (default: {})", d))
                .unwrap_or_default();

            println!(
                "    {} <{}>  {}{}",
                format!("--{}", param.name).cyan(),
                type_str,
                desc,
                default_str.dimmed(),
            );

            if let Some(ref choices) = param.choices {
                let choices_str: Vec<String> = choices
                    .iter()
                    .map(|c| match c {
                        serde_json::Value::String(s) => s.clone(),
                        other => other.to_string(),
                    })
                    .collect();
                println!("      {}: {}", "choices".dimmed(), choices_str.join(", "));
            }
            if let Some(min) = param.min {
                print!("      {}: {min}", "min".dimmed());
            }
            if let Some(max) = param.max {
                print!("  {}: {max}", "max".dimmed());
            }
            if param.min.is_some() || param.max.is_some() {
                println!();
            }
        }
    }

    println!("\n  {}:", "Query".bold());
    for line in query.sql.lines() {
        println!("    {}", line.dimmed());
    }

    if let Some(ref tmpl) = query.metadata.template {
        println!("\n  {}:", "Template".bold());
        for line in tmpl.lines() {
            println!("    {}", line.dimmed());
        }
    }

    Ok(())
}

async fn generate(description: &str, project: bool, quiet: bool) -> Result<()> {
    let config = Config::load()?;

    let ai_config = config.ai.as_ref().ok_or_else(|| {
        anyhow::anyhow!(
            "AI is not configured. Add an `ai` section to your config:\n\n\
             ai:\n\
             \x20 account: <azure-openai-account>\n\
             \x20 deployment: <model-deployment-name>"
        )
    })?;

    let ai_client = cosq_client::openai::AzureOpenAIClient::from_config(ai_config).await?;

    if !quiet {
        eprintln!("{}", "Generating stored query...".dimmed());
    }

    let system_prompt = r#"You are a Cosmos DB SQL query generator. Generate a stored query in .cosq format.

The .cosq format uses YAML front matter between --- delimiters, followed by the SQL query.

Rules:
- Use 'c' as the alias for the container (e.g., SELECT * FROM c)
- Use Cosmos DB SQL syntax (not ANSI SQL). Use TOP instead of LIMIT.
- Extract variable parts as parameters using @param syntax in the SQL
- Parameters must be defined in the params section with name, type (string/number/bool), description, and optional default/choices
- Generate a clear, concise description field
- If the query returns tabular data, include a MiniJinja template that presents results clearly
- The template uses {{ variable }} syntax and {% for doc in documents %} loops
- Template has access to 'documents' (array of results) and all parameter values
- Respond with ONLY the .cosq file content, no explanation or markdown fences

Example output:
---
description: Find active users by role
params:
  - name: role
    type: string
    description: User role to filter by
    choices: ["admin", "editor", "viewer"]
    default: "viewer"
  - name: limit
    type: number
    description: Maximum results
    default: 20
    min: 1
    max: 100
template: |
  {{ role | capitalize }} users:
  {% for doc in documents %}
  - {{ doc.displayName }} ({{ doc.email }})
  {% endfor %}
  Total: {{ documents | length }}
---
SELECT TOP @limit c.id, c.displayName, c.email, c.role
FROM c
WHERE c.role = @role AND c.status = "active"
ORDER BY c.displayName
"#;

    let user_prompt = format!("Generate a .cosq stored query for: {description}");

    let response = ai_client
        .chat_completion(system_prompt, &user_prompt, 0.3, 2000)
        .await
        .context("failed to generate query")?;

    // Clean up response (strip markdown fences if present)
    let content = response
        .trim()
        .strip_prefix("```yaml")
        .or_else(|| response.trim().strip_prefix("```"))
        .unwrap_or(response.trim())
        .strip_suffix("```")
        .unwrap_or(response.trim())
        .trim();

    // Validate the generated query parses correctly
    let mut query = StoredQuery::parse("generated", content)
        .context("AI generated an invalid query file. Try rephrasing your description.")?;

    // Add AI metadata
    query.metadata.generated_by = Some("ai".to_string());
    query.metadata.generated_from = Some(description.to_string());

    // Generate a filename from the description
    let suggested_name = generate_filename(description);

    // Show preview
    eprintln!("\n{}", "Generated query:".bold());
    eprintln!("  {} {}", "Name:".dimmed(), suggested_name.green());
    eprintln!(
        "  {} {}",
        "Description:".dimmed(),
        query.metadata.description
    );
    if !query.metadata.params.is_empty() {
        eprintln!("  {}:", "Parameters".dimmed());
        for p in &query.metadata.params {
            eprintln!("    --{} <{}>", p.name, p.param_type);
        }
    }
    eprintln!("\n  {}:", "SQL".dimmed());
    for line in query.sql.lines() {
        eprintln!("    {}", line.cyan());
    }

    // Ask for name (or accept suggestion)
    let name: String = dialoguer::Input::with_theme(&dialoguer::theme::ColorfulTheme::default())
        .with_prompt("Query name")
        .default(suggested_name)
        .interact_text()
        .context("input cancelled")?;

    query.name = name.clone();

    // Save
    let path = query_file_path(&name, project)?;
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent)?;
    }
    let contents = query.to_file_contents()?;
    std::fs::write(&path, &contents)?;

    println!("{} Saved to {}", "OK".green().bold(), path.display());

    // Offer to open in editor
    let edit = dialoguer::Confirm::with_theme(&dialoguer::theme::ColorfulTheme::default())
        .with_prompt("Open in editor to review?")
        .default(true)
        .interact()
        .context("confirmation cancelled")?;

    if edit {
        open_in_editor(&path)?;
    }

    Ok(())
}

/// Generate a kebab-case filename from a natural language description
fn generate_filename(description: &str) -> String {
    let words: Vec<&str> = description
        .split_whitespace()
        .filter(|w| {
            !matches!(
                w.to_lowercase().as_str(),
                "find"
                    | "get"
                    | "list"
                    | "show"
                    | "select"
                    | "all"
                    | "the"
                    | "a"
                    | "an"
                    | "from"
                    | "in"
                    | "of"
                    | "by"
                    | "with"
                    | "who"
                    | "that"
                    | "are"
                    | "is"
                    | "and"
                    | "or"
                    | "for"
                    | "to"
            )
        })
        .take(4)
        .collect();

    let name = words.join("-").to_lowercase();
    // Remove non-alphanumeric chars except hyphens
    name.chars()
        .filter(|c| c.is_alphanumeric() || *c == '-')
        .collect()
}

/// Open a file in the user's default editor
fn open_in_editor(path: &std::path::Path) -> Result<()> {
    let editor = std::env::var("VISUAL")
        .or_else(|_| std::env::var("EDITOR"))
        .unwrap_or_else(|_| {
            if cfg!(target_os = "macos") {
                "open".to_string()
            } else if cfg!(target_os = "windows") {
                "notepad".to_string()
            } else {
                "xdg-open".to_string()
            }
        });

    eprintln!("{} Opening in {editor}...", ">>".dimmed());

    std::process::Command::new(&editor)
        .arg(path)
        .status()
        .with_context(|| format!("failed to open editor: {editor}"))?;

    Ok(())
}

/// Find the file path for a stored query by name (checking project then user dir)
fn find_query_path(name: &str) -> Result<std::path::PathBuf> {
    let filename = if name.ends_with(".cosq") {
        name.to_string()
    } else {
        format!("{name}.cosq")
    };

    if let Some(project_dir) = cosq_core::stored_query::project_queries_dir() {
        let path = project_dir.join(&filename);
        if path.exists() {
            return Ok(path);
        }
    }

    let user_dir = user_queries_dir().map_err(|e| anyhow::anyhow!("{e}"))?;
    let path = user_dir.join(&filename);
    if path.exists() {
        return Ok(path);
    }

    bail!("Query '{name}' not found. Run `cosq queries list` to see available queries.")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_filename() {
        assert_eq!(
            generate_filename("Find all users who signed up in the last 30 days"),
            "users-signed-up-last"
        );
        assert_eq!(generate_filename("orders over $100"), "orders-over-100");
        assert_eq!(
            generate_filename("active subscriptions"),
            "active-subscriptions"
        );
    }

    #[test]
    fn test_generate_filename_empty_input() {
        let name = generate_filename("users");
        assert_eq!(name, "users");
    }
}
